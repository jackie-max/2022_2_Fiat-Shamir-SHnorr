import random
from Crypto.Util.number import *

#Предварительный этап
#Центр доверия T: получаем случайные простые числа p и q
p = getPrime(10)
q = getPrime(10)
n = p*q

#S регистрируется как закрытый ключ пользователя
S = bytes_to_long(b'Something')
print("Тип S:", type(S))

#V регистрируется как открытый ключ пользователя, V = S^2 mod n
V = pow(S, 2, n)

print("Закрытый ключ = ", S)
print("Открытый ключ = ", V)
print("Произведение, переданное от центра доверия T = ", n)

count = 0
#задаём число итераций равное 4
for i in range(4):

	#Основной этап
	#Пункт 1.
	#Доказывающий P выбирает случайное r
	r = random.randint(1, n-1)
	#Отправляет проверяющему V значение x = r^2 mod n
	x = pow(r, 2, n)

        #Пункт 2.
	#Проверяющий e случайно выбирает бит e = {0, 1}
	e = random.randint(0, 1)

	#Пункт 3.
	#Доказывающий P вычисляет значение y = r*S^e mod n
	y = (r*(S**e))%n

        #Пункт 4.
	#V проверяет равенство y^2 = x*V^e mod n
	#Если равенство верное, то протокол завершен корректно, иначе доказательство не принимается
	print("______________________________________________________")
	print("Номер итерации: "+str(i+1))
	print("Значение r: ", r)
	print("Значение x: ", x)
	print("Значение e: ", e)
	print("Значение y: ", y)
	print("Значение y^2: = ", pow(y,2,n))
	print("Значение (x*V^e mod n): ", (x*(V**e))%n)

	print("Итерация номер "+str(i+1)+":	", end="")
	if(pow(y,2,n) == (x*(V**e))%n):
		print("завершена успешно")
		count += 1
	else:
		print("провалена")

if(count == 4):
	print("Аутентификация завершена успешно")
else:
	print("Аутентификация провалена")
	
